On plumbing and ..

This sections explains the benefits of message queues, and the specifics of TurtleQueue.

## Why turtlequeue

In order to understand why TurtleQueue, we need to look back at what are queues, their benefits, and the current state of the art.

### Message queues

Message queues / brokers are a big topic. I am assuming at least a passing familiarity with these.
However the core idea is simple.
Programs need to exchange data between them continuously.
One way to move data from one place to another is to use a message queues.

There are many differences between queues (broker-based, smart clients, persistent or not, streaming or batching etc.) but the core idea is that messages are put into named queues. Named queues work similarly to hashtags.

So you have producers that have message and choose a tag to publish the message to a named queue.
And at the other end of the queue you have a consumer that is consuming messages from that queue.

IMAGE


This is a very useful to do, because the producers and the consumers are now decoupled.

You can have multiple consumers. Or none. Multiple producers. Or none. You can add or remove some at any time.
You can restart the consumers and producers independently without them noticing, since the messages will be kept in the queue until consumed.
You can peek at the queue and see how many messages it holds. You can process messages straight away, or in the background, or periodically in large groups.

Message queues decouple the what from the when, and reduce the knowledge needed for an application to work.
This gives us:
- reliability in the face of failure
- increased flexibility by use of decoupling
- increased scalability
- increased observability

All these benefits explain the popularity of message queues, like RabbitMQ, zeroMQ, ActiveMQ and many others.


## Distributed log

More recently, message queues have had one major evolution. Their internal representation of the messages are now centered around an append-only log. This has important performance implications, and because messages are kept in store instead of being discarded after being consumed, it did open up new possibilities for application developers.

New architectures have emerged and are still being improved upon (lambda architecture and ETL friends).

So now you still have producers that push messages onto a named queue, but consumers can decide which part they want to read. They can start from the incoming messages, or

Apache Pulsar (upon which TurtleQueue is built) uses the concept of a cursor, that advances to consume the next message. But the cursor's position can be changed to something else, like the beginning of the queue.

IMAGE

This approach was popularized by Apache Kafka and other technologies like Apache Pulsar. In addition they offer advanced features (KStreams from Apache Kafka, Functions from Apache Pulsar and others)

## Come TurtleQueue

These great systems have two main downsides.

These systems are very complex and require an upfront investment before being used.
Their different parts need to be understood, installed, secured, monitored, scaled, updated...
Only them can applications use them.

TurtleQueue aims to minimize all of the above:
- have a collection of examples for common use cases
- start without installing anything, and move to an on-premises installation later if needed
- provide visual monitoring and feedback via it's dashboard

They also all share one fundamental construction the different queue names (or channels, tags, hashtags, topics) is everything that identifies where a message should go.
These names are usually defined by the programmer upfront, and exctly _how_ a message ends up in a named queue or another is left to the application programmer entirely, leaving this complex part completely up to him.

I believe that in a lot of cases this is too unflexible, and that the role of a messaging platform should be to help support different messaging patterns out of the box.

IMAGE

So in the above image subscribers have expressed their interest in message. New messages will get delivered to their inbox, depending on specific criteria. These can be a simple name or more complex filters or patterns.

TurtleQueue aims to support common use cases:
- simple GET / POST requests from a web client without having to install a library
- updating a subscriber's criteria on the fly, while keeping previous messages
- request/response patterns
- delayed or periodic background jobs
