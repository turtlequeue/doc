This sections explains the benefits of message queues, and the specifics of TurtleQueue.

## Why turtlequeue

In order to understand why TurtleQueue, we need to look back at what are queues, their benefits, and the current state of the art.

### Message queues

Message queues / brokers are a big topic. I am assuming at least a passing familiarity with these.
However the core idea is simple.
Programs need to exchange data between them continuously.
One way to move data from one place to another is to use a message queues.

There are many differences between queues (broker-based, smart clients, persistent or not, streaming or batching etc.) but the core idea is that messages are put into named queues. Named queues work similarly to hashtags.

So you have producers that have message and choose a tag to publish the message to a named queue.
And at the other end of the queue you have a consumer that is consuming messages from that queue.

IMAGE


This is a very useful to do, because the producers and the consumers are now decoupled.

You can have multiple consumers. Or none. Multiple producers. Or none. You can add or remove some at any time.
You can restart the consumers and producers independently without them noticing, since the messages will be kept in the queue until consumed.
You can peek at the queue and see how many messages it holds. You can process messages straight away, or in the background, or periodically in large groups.

Message queues decouple the what from the when, and reduce the knowledge needed for an application to work.
This gives us:
- reliability in the face of failure
- increased flexibility by use of decoupling
- increased scalability
- increased observability

All these benefits explain the popularity of message queues, like RabbitMQ, zeroMQ, ActiveMQ and many others.


## Distributed log

More recently, message queues have had one major evolution. Their internal representation of the messages are now centered around an append-only log. This has important performance implications, and because messages are kept in store instead of being discarded after being consumed, it did open up new possibilities for application developers.

New architectures have emerged and are still being improved upon (lambda architecture and ETL friends).

So now you still have producers that push messages onto a named queue, but consumers can decide which part they want to read. They can start from the incoming messages, or

Apache Pulsar (upon which TurtleQueue is built) uses the concept of a cursor, that advances to consume the next message. But the cursor's position can be changed to something else, like the beginning or the queue.

IMAGE


This approach was popularized by Apache Kafka and other technologies like Apache Pulsar.


## What is the catch?

So message
and now we have had many nice solutions:

- Apache Kafka
- Apache Pulsar Functions, which have the same benefits of lambda / serverless functions regarding ease of deployment, but can hold state.
- offload to a different store like Apache Pulsar (using S3 for instance)

...But this comes at a cost. These need to be configured, deployed, maintained, scaled, updated...

Also there are inevitable some very repetitive applications that have to be built on top of these.

I do not count how many times I built or witnessed a simple REST app being build that does nothing but put messages onto a queue. Unfortunate but necessary as these systems are not built for the web.

Although these systems do provide some sort of monitoring,
advanced dashboard. Plans for tracing built-in.

And then, the most important of them all. Because it is expensive to make these named queues, and because names can only take us so far,
There are invariably some parameters that will

Don't get me wrong, good names are great.
But when you rely on naming only for your channels the structure of the messaging can be very inflexible, and a consequence is that the queues are not used to their full potential. Which is what we were trying to solve in the first place!


## Come turtlequeue

TurtleQueue is build on top of the state of the art message broker Apache Pulsar, and inherits a lot of it's characteristics.
It does not try to solve the impossible, everything TurtleQueue does is _already_ possible with modern messages brokers.

_However_ the upfront investment and continuous effort required to use these tools, along with their inability to unlock the value of message queues makes me believe that there is room for TurtleQueue.

Turtlequeue

TurtleQueue adds unique features as well
But it also provides it's own value:
- provides the same
- it is hosted so all the above regarding deployments are not your problem. It can be hosted in a private cloud as well if needed (our entire infrastructure runs on kubernetes)
-


There are roughly two categories where

### Ease of use
Lower upfront costs. Higher long-term velocity

### Improved
Better introspection, improved debugging


### References

Rich?


Zach Tellman "Queues separate the 'What' from the 'When'"
https://youtu.be/1bNOO3xxMc0?t=206
