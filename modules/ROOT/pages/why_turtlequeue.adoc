This article explains the benefits of message queues and their evolution, up to the philosophy behind TurtleQueue.

## TurtleQueue

In order to understand TurtleQueue purpose, we need to look back at what message queues are.

### Message queues

Message queues / message brokers are a big topic, with many variations not discussed here. However the core idea is simple.
Programs need to exchange data between them all the time. One good way to move data from one place to another is to use message queues.

There are too many differences between systems to cover here (queue or publish-subscribe model, smart broker or smart clients, persistent or not, distributed or not, streaming or batching ..). However, they all share similar principles: messages are put into named queues.

These are called diferently depending on the specific technology used (channels, topics).
They can be described by having producers and consumers putting and getting messages from a specific queue (or channel, or topic)..

IMAGE

So you have producers that have messages and choose a named queue to send the message to.
And at the other end of the queue you have a consumer that is consuming messages from that specific queue.

This is a very useful to do, because the producers and the consumers are now decoupled, isolated by the queues.
This decoupling means consumers and producers do not need to know about each other. They can be updated independently. The messages will be kept in the queue until consumed.

Several consumers or producers can coexist, along with several named queues.
It is possible to peek at the queue and see how many messages it holds. Messages can be processed straight away, or in the background, or periodically in large groups.

Message queues decouple the _what_ from the _when_, and reduce the knowledge needed for an application to work.
This gives us increased reliability and observability.

All these benefits explain the popularity of message queues, like RabbitMQ, zeroMQ, ActiveMQ and many others.

## Distributed log

More recently, message queues have had one major evolution, that was popularized by Apache Kafka. Their internal representation of the messages are now centered around an append-only log. This has important performance implications, and because messages are kept in store instead of being discarded after being consumed, it did open up new possibilities for application developers.

New architectures have emerged and are still being improved upon, like the lambda architecture..

So now you still have producers that push messages onto a named queue, but consumers can decide which part they want to read. They can start from the incoming messages, or from the start of the topic.

Apache Pulsar (upon which TurtleQueue is built) uses the concept of a cursor, that advances to consume the next message. But the cursor's position can be changed to something else, like the beginning of the queue.

IMAGE

 In addition they offer advanced features (KStreams from Apache Kafka, Functions from Apache Pulsar and others)

## Come TurtleQueue

These great systems have two main downsides.

These systems are very complex and require an upfront investment before being used.
Their different parts need to be understood, installed, secured, monitored, scaled, updated...
Only them can applications use them.

TurtleQueue aims to minimize all of the above:
- have a collection of examples for common use cases
- start without installing anything, and move to an on-premises installation later if needed
- provide visual monitoring and feedback via it's dashboard

They also all share one fundamental construction the different queue names is everything that identifies where a message should go.
These names are usually defined by the programmer upfront, and exctly _how_ a message ends up in a named queue or another is left to the application programmer entirely, leaving this complex part completely up to him.

I believe that in a lot of cases this is too unflexible, and that the role of a messaging platform should be to help support different messaging patterns out of the box.

IMAGE

So in the above image subscribers have expressed their interest in message. New messages will get delivered to their inbox, depending on specific criteria. These can be a simple name or more complex filters or patterns.

TurtleQueue aims to support common use cases:
- simple GET / POST requests from a web client without having to install a library
- updating a subscriber's criteria on the fly, while keeping previous messages
- request/response patterns
- delayed or periodic background jobs
